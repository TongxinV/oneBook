随笔--linux设备驱动模型
=======================

> 以`kobject`为底层，组织`类class`、`总线bus`、`设备device`、`驱动driver`等高级数据结构，同时实现对象引用计数、维护对象链表、对象上锁、对用户空间的表示等服务

参考博客:<br>
Linux设备驱动模型http://blog.csdn.net/xiahouzuoxin/article/details/8943863<br>
Linux设备模型--设备驱动模型和sysfs文件系统解读http://www.cnblogs.com/Ph-one/p/5052191.html

[TOC]

### linux设备驱动模型简介

    何谓linux驱动设备模型。其实驱动开发中已经涉及到这方面的知识，并且也用到驱动设备模型，只是并没有从驱动设备模型这个角度去理解
    文章站在设备驱动这个角度取分析，设备驱动模型是如何构建出来的，代码是谁写的，起到什么作用，要对它认识到一个怎么样的程度以及写
    驱动的时候如何去利用设备驱动模型

####什么是设备驱动模型
> 从以下几个角度去描述折别驱动模型

1. 类class、总线bus、设备device、驱动driver


        这四个词并不是四个简单的概念，这四个东西分别是我们linux驱动的四个结构体，也就是说这是我们linux设备驱动模型的四个框架。
        分别对应我们源代码的四个结构体。
            class ：例如class_create
            bus   ：例如USB总线，SPI总线
            device：设备
            driver：驱动
        我们要这四个结构体干嘛-----生产这些结构体类型的变量，每一个结构体变量就能代表一个实例

2. kobject和对象生命周期的管理


        linux内核源代码里面的一个结构体，k是kernel object物体，kobject就是内核的一个东西。一个高度抽象的结构体，表示我们内
        核里面的一个对象，就是内核里面的所有对象抽象出来的一个总类。所以我们说linux内核是面向对象编程。这个kobject就有点像面
        向对象体系的一个总的基类，总的父类
        
        对象生命周期，例如某一个驱动，insmod诞生，rmmod消亡。如何管理这个对象的生命周期呢？在kobject有一种机制，能够让每一个
        对象具有自我管理生命周期的特性，就是自己管理自己，当自身不被需要的时候就自己释放。比如为A malloc 申请一段内存，当不需
        要的时候不用去free A，它自己会自己free掉。那他怎么就知道自己没用了呢？肯定需要一种方法

3. sysfs

        在内核空间和我们用户空间建立一个映射关系
        
4. udev

        为了实现内核空间和用户空间的信息的一个同步
        
####为什么需要设备驱动模型

    (1)早期内核（2.4之前）没有统一的设备驱动模型，但照样可以用
    (2)2.6版本中正式引入设备驱动模型，目的是在设备越来越多，功耗要求等新特性要求的情况下让驱动体系更易用、更优秀
    (3)设备驱动模型负责统一实现和维护一些特性，诸如：电源管理、热插拔、对象生命周期、用户空间和驱动空间的交互等基础设施
    (4)设备驱动模型目的是简化驱动程序编写，但是客观上设备驱动模型本身设计和实现很复杂。我们主要学会怎么用

**驱动开发的2个点**:

    (1)驱动源码本身编写、调试。重点应该在于对硬件的了解。比如触摸屏有几百个寄存器
    (2)驱动什么时候被安装(被安装就是insmod，但是不是像我们之前那样开机之后在用户空间insmod，我们需要的方式是自动的，比如一
    个触摸屏的芯片已经装上，开机后他就能够自动装上，然后一拔掉这个驱动就自己卸载)、驱动中的函数什么时候被调用(即在应用层怎么
    做就能调用驱动写好的东西)。这些跟硬件无关，完全和设备驱动模型有关

### 设备驱动模型的底层架构

####kobject
![p.5-3-11](https://raw.githubusercontent.com/TongxinV/oneBook/master/0.5.Linux-Driver%20Development/assets/%E5%9B%BE%E7%89%87.5-3-11.png)

    (1)定义在linux/kobject.h中
    (2)各种对象最基本单元，提供一些公用型服务如：对象引用计数、维护对象链表、对象上锁、对用户空间的表示
    (3)设备驱动模型中的各种对象其内部都会包含一个kobject
    (4)地位相当于面向对象体系架构中的总基类

####kobj_type
![p.5-3-12](https://raw.githubusercontent.com/TongxinV/oneBook/master/0.5.Linux-Driver%20Development/assets/%E5%9B%BE%E7%89%87.5-3-12.png)

    (1)很多书中简称为ktype，每一个kobject都需要绑定一个ktype来提供相应功能
                                                   (绑定和包含意思不一样，包含是实体，绑定是实体的一个指针)
    (2)关键点0:release，释放。用release而不用close，因为我们可能需要反复去打开，你第一次打开第二次打开你就打开了两次，如果
    你用close就一次把两个都关掉了。release不一样，我们去release它，我们会先判断有没有被别人打开过如果它还被其他人打开着，那
    么我就只是减少它的一次引用计数；如果它没有被其他打开，当前就只有我打开它，那我要关闭就彻底的把它的东西全部释放掉
    
    (3)关键点1：sysfs_ops，提供该对象在sysfs中的操作方法(show和store)
    struct sysfs_ops {
        ssize_t (*show )(struct kobject *, struct attribute *,char *);
        ssize_t (*store)(struct kobject *,struct attribute *,const char *, size_t);
    };
    show方法用于将传入的指定属性编码后放到char *类型的buffer中
    store则执行相反功能：将buffer中的编码信息解码后传递给struct attribute类型变量。两者都是返回实际的属性长度
    
    (4)关键点2：attribute，提供在sysfs中以文件形式存在的属性，其实就是应用接口
    struct attribute {
        const char *name;/* 属性名称 */
        mode_t mode;     /* 属性保护：只读设为S_IRUGO，可写设为S_IWUSR */
    }
    
### 总线式设备驱动组织方式

<p style="color:red;">
    這個段落同樣會被顯示為黃底紅字粗體。
</p>



> 驱动这个东西并不复杂，就是由我们讲的这些理论来指导，就是由我们的实践来构成







