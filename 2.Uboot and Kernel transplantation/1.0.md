
以下代码在
```c
#include <config.h>
/*config.h是在include目录下的，这个文件不是源码中本身存在的文件，而是配置过程中自动生成的文件（详见mkconfig脚本）。
这个文件的内容其实是包含了一个头文件：#include <configs/x210_sd.h>.*/
#include <version.h>
#if defined(CONFIG_ENABLE_MMU)
#include <asm/proc/domain.h>
/*asm目录不是uboot中的原生目录，uboot中本来是没有这个目录的。asm目录是配置时创建的一个符号链接，实际指向的是就是
asm-arm（详见mkconfig）*/
#endif
#include <regs.h>
#ifndef CONFIG_ENABLE_MMU
#ifndef CFG_PHY_UBOOT_BASE 
#define CFG_PHY_UBOOT_BASE	CFG_UBOOT_BASE /* uboot在DDR中的物理地址 */
#endif
#endif

/* Jump vector table as in table 3.1 in [1] */
#if defined(CONFIG_EVT1) && !defined(CONFIG_FUSED) /* 启动代码的16字节头部 */
	.word 0x2000
	.word 0x0
	.word 0x0
	.word 0x0
#endif

.globl _start
_start: b	reset    /* 跳转到标号reset处 */
		......
......
/* 一些标号的定义 */
.global _end_vect
_end_vect:
	.balignl 16,0xdeadbeef
	/* 让当前地址对齐排布，如果当前地址不对齐则自动向后走地址直到对齐，并且向后走的那些内存要用0xdeadbeef来填充 */
......
.globl _bss_start    /* __bss_start、_bss_end: 清bss段会用到 */
_bss_start:
	.word __bss_start

.globl _bss_end
_bss_end:
	.word _end
......
/*
 * the actual reset code
 */
reset:
	msr	cpsr_c, #0xd3		/* I & F disable, Mode: 0x13 - SVC模式 */
	
cpu_init_crit:	
	/* CPU初始化: 设置L2、L1cache和MMU */
	......	
	
	/* Read booting information    读取启动信息到r2，判断出启动介质后将一特殊值存到r3， 再将r3中的值存于一寄存器中 */
	ldr	r0, =PRO_ID_BASE
    ldr	r1, [r0,#OMR_OFFSET]
    bic	r2, r1, #0xffffffc1
	......
	/* SD/MMC BOOT */
	cmp     r2, #0xc
	moveq   r3, #BOOT_MMCSD	

	/* NOR BOOT */
	cmp     r2, #0x14
	moveq   r3, #BOOT_NOR	
	......
	ldr	r0, =INF_REG_BASE
	str	r3, [r0, #INF_REG3_OFFSET]	
	
	/* 设置栈为了在内部96KB的iRAM中使用栈，调用lowlevel_init——时钟和DDR的初始化，初始化串口，打印'OK' */
	ldr	sp, =0xd0036000 /* end of sram dedicated to u-boot */
	sub	sp, sp, #12	/* set stack */
	mov	fp, #0
	
	bl	lowlevel_init	/* go setup pll,mux,memory */
	
	
	
	
	

```
